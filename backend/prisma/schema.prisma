generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-arm64-openssl-3.0.x", "linux-arm64-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Users {
  id           Int           @id @default(autoincrement())
  username     String        @unique
  email        String        @unique
  password     String
  role         Role          @default(USER)
  createdAt    DateTime      @default(now())
  wordEdits    WordEdit[]
  wordRequests WordRequest[]
  words        Words[]
  editedWords  Words[]       @relation("WordEditor")
}

model Words {
  id                        Int              @id @default(autoincrement())
  word                      String
  description               String
  createdAt                 DateTime         @default(now())
  updatedAt                 DateTime         @updatedAt
  creatorId                 Int
  dialectId                 Int?
  dominantHand              Hand?
  facialExpression          String?
  hasContact                Boolean?
  isNative                  Boolean          @default(true)
  lexicalCategory           LexicalCategory?
  morphologicalVariants     String?
  movementType              String?
  nonManualComponents       String?
  phonologicalTranscription String?
  register                  String?
  requestId                 Int?             @unique
  status                    WordStatus       @default(PENDING)
  usageEra                  String?
  usageFrequency            String?
  originalWordId            Int?
  editorId                  Int?
  editComment               String?
  senses                    Sense[]
  translations              Translation[]
  videos                    Video[]
  edits                     WordEdit[]
  relatedWords              WordRelation[]   @relation("SourceWord")
  relatedToWords            WordRelation[]   @relation("TargetWord")
  creator                   Users            @relation(fields: [creatorId], references: [id])
  editor                    Users?           @relation("WordEditor", fields: [editorId], references: [id])
  dialect                   Dialect?         @relation(fields: [dialectId], references: [id])
  originalRequest           WordRequest?     @relation("OriginalRequest", fields: [requestId], references: [id])
  originalWord              Words?           @relation("WordVersions", fields: [originalWordId], references: [id])
  wordVersions              Words[]          @relation("WordVersions")
}

model WordEdit {
  id               Int        @id @default(autoincrement())
  wordId           Int
  editorId         Int
  comment          String?
  status           EditStatus @default(PENDING)
  denyReason       String?
  newWordVersionId Int?
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt
  editor           Users      @relation(fields: [editorId], references: [id])
  word             Words      @relation(fields: [wordId], references: [id])
}

model Video {
  id        Int      @id @default(autoincrement())
  url       String
  angle     String
  wordId    Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  priority  Int      @default(0)
  word      Words    @relation(fields: [wordId], references: [id], onDelete: Cascade)

  @@index([priority, wordId])
}

model Dialect {
  id             Int      @id @default(autoincrement())
  name           String
  region         String
  mapCoordinates String?
  description    String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  words          Words[]
}

model Sense {
  id          Int           @id @default(autoincrement())
  definition  String
  example     String?
  wordId      Int
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  priority    Int           @default(0)
  word        Words         @relation(fields: [wordId], references: [id], onDelete: Cascade)
  Translation Translation[]

  @@index([priority, wordId])
}

model Translation {
  id        Int      @id @default(autoincrement())
  text      String
  language  Language
  senseId   Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  sense     Sense    @relation(fields: [senseId], references: [id], onDelete: Cascade)
  Words     Words?   @relation(fields: [wordsId], references: [id])
  wordsId   Int?

  @@unique([senseId, language])
}

model WordRelation {
  id           Int          @id @default(autoincrement())
  sourceWordId Int
  targetWordId Int
  relationType RelationType
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  sourceWord   Words        @relation("SourceWord", fields: [sourceWordId], references: [id])
  targetWord   Words        @relation("TargetWord", fields: [targetWordId], references: [id])

  @@unique([sourceWordId, targetWordId, relationType])
}

model WordRequest {
  id          Int           @id @default(autoincrement())
  word        String
  description String
  videoUrl    String
  userId      Int
  status      RequestStatus @default(PENDING)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  denyReason  String?
  user        Users         @relation(fields: [userId], references: [id])
  createdWord Words?        @relation("OriginalRequest")
}

enum Role {
  ADMIN
  USER
}

enum RequestStatus {
  PENDING
  ACCEPTED
  DENIED
}

enum Language {
  CATALAN
  SPANISH
  ENGLISH
  OTHER
}

enum LexicalCategory {
  NOUN
  VERB
  ADJECTIVE
  ADVERB
  PRONOUN
  DETERMINER
  PREPOSITION
  CONJUNCTION
  INTERJECTION
  OTHER
}

enum RelationType {
  SYNONYM
  REGIONAL_VARIANT
  ASSOCIATED_CONCEPT
  ANTONYM
  HYPERNYM
  HYPONYM
}

enum Hand {
  RIGHT
  LEFT
  BOTH
}

enum WordStatus {
  PENDING
  PUBLISHED
  ARCHIVED
  EDIT_REQUEST
  REJECTED
}

enum EditStatus {
  PENDING
  APPROVED
  REJECTED
}
