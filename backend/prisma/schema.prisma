generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-arm64-openssl-3.0.x", "linux-arm64-openssl-3.0.x", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

// Define embedded types for MongoDB document structure
type SenseTranslation {
  translation String
  language    Language
}

type Description {
  description  String
  examples     String[]
  translations SenseTranslation[] // Embedded translations
}

type Sense {
  priority              Int
  morphologicalVariants String?
  usageEra              String?
  usageFrequency        String?
  descriptions          Description[]
  videos                Video[]
  lexicalCategory       LexicalCategory?
}

type Video {
  url                       String
  angle                     String
  priority                  Int
  dominantHand              Hand?
  facialExpression          String?
  hasContact                Boolean?
  phonologicalTranscription String?
  nonManualComponents       String?
  movementType              String?
}

// Define embedded type for related words
type RelatedWord {
  wordId       String       @db.ObjectId
  relationType RelationType
}

// Comprehensive Word type to be used across models
type Word {
  word     String
  isNative Boolean @default(true)

  // Embedded document structures
  senses       Sense[] // Embedded senses with their translations and descriptions
  relatedWords RelatedWord[] // Embedded related words
  dialectId    String?       @db.ObjectId // Store just the ID reference
}

model Users {
  id                   String        @id @default(auto()) @map("_id") @db.ObjectId
  username             String        @unique
  email                String        @unique
  password             String
  role                 Role          @default(USER)
  createdAt            DateTime      @default(now())
  wordEdits            WordEdit[]    @relation("UserWordEdits")
  wordRequests         WordRequest[] @relation("UserWordRequests")
  WordRequestsAccepted WordRequest[] @relation("AcceptedBy")
  WordRequestsDenied   WordRequest[] @relation("DeniedBy")
}

// New separate Dialect model
model Dialect {
  id             String   @id @default(auto()) @map("_id") @db.ObjectId
  name           String   @unique
  region         String
  mapCoordinates String?
  description    String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model WordEntry {
  id                   String     @id @default(auto()) @map("_id") @db.ObjectId
  createdAt            DateTime   @default(now())
  updatedAt            DateTime   @updatedAt
  status               WordStatus @default(PUBLISHED) // Only PUBLISHED or EDIT_REQUEST
  editComment          String?
  currentVersion       Int        @default(1) // Track version number
  isCreatedFromRequest Boolean
  isCreatedFromEdit    Boolean
  wordRequestId        String?    @db.ObjectId

  // Word data as embedded type
  wordData Word

  // Relations to external collections
  edits       WordEdit[]
  // Relations to other models
  wordRequest WordRequest?
}

model WordEdit {
  id               String     @id @default(auto()) @map("_id") @db.ObjectId
  wordId           String     @db.ObjectId
  editorId         String     @db.ObjectId
  comment          String?
  status           EditStatus @default(PENDING)
  denyReason       String?
  newWordVersionId String?    @db.ObjectId // References a temporary version in Words with EDIT_REQUEST status
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  // Proposed changes using the Word type
  currentWordData  Word? // Original word data
  proposedWordData Word? // Proposed word data

  // Alternatively, store as JSON if needed
  proposedChanges Json?

  // Relations
  editor Users     @relation("UserWordEdits", fields: [editorId], references: [id])
  word   WordEntry @relation(fields: [wordId], references: [id])
}

model WordEditHistoric {
  id             String   @id @default(auto()) @map("_id") @db.ObjectId
  originalWordId String   @db.ObjectId // Reference to the current word
  archivedAt     DateTime @default(now())
  wordData       Json // Complete snapshot of the word at this version
  versionNumber  Int // Track version number
}

model WordRequest {
  id           String        @id @default(auto()) @map("_id") @db.ObjectId
  creatorId    String        @db.ObjectId
  activeWordId String?       @db.ObjectId
  status       RequestStatus @default(PENDING)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  denyReason   String?
  acceptedBy   Users?        @relation("AcceptedBy", fields: [acceptedById], references: [id])
  acceptedById String?       @db.ObjectId
  deniedBy     Users?        @relation("DeniedBy", fields: [denyerId], references: [id])
  denyerId     String?       @db.ObjectId

  // Word data using the Word type
  requestedWordData Word

  // Relations
  user Users @relation("UserWordRequests", fields: [creatorId], references: [id])

  wordEntry WordEntry? @relation(fields: [wordId], references: [id])
  wordId    String?    @unique @db.ObjectId
}

enum Role {
  ADMIN
  USER
}

enum RequestStatus {
  PENDING
  ACCEPTED
  DENIED
}

enum Language {
  CATALAN
  SPANISH
  ENGLISH
  OTHER
}

enum LexicalCategory {
  NOUN
  VERB
  ADJECTIVE
  ADVERB
  PRONOUN
  DETERMINER
  PREPOSITION
  CONJUNCTION
  INTERJECTION
  OTHER
}

enum RelationType {
  SYNONYM
  REGIONAL_VARIANT
  ASSOCIATED_CONCEPT
  ANTONYM
  HYPERNYM
  HYPONYM
}

enum Hand {
  RIGHT
  LEFT
  BOTH
}

enum WordStatus {
  PUBLISHED
  ARCHIVED
}

enum EditStatus {
  PENDING
  APPROVED
  REJECTED
}
